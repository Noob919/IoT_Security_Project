{
  "cells": [
    {
      "cell_type": "markdown",
      "metadata": {
        "id": "view-in-github",
        "colab_type": "text"
      },
      "source": [
        "<a href=\"https://colab.research.google.com/github/Noob919/IoT_Security_Project/blob/main/Noob919/IoT_Security_Project/tree/main/Christophe%2520GUYEUX\" target=\"_parent\"><img src=\"https://colab.research.google.com/assets/colab-badge.svg\" alt=\"Open In Colab\"/></a>"
      ]
    },
    {
      "cell_type": "markdown",
      "id": "82e17c3a",
      "metadata": {
        "id": "82e17c3a"
      },
      "source": [
        "# <b>IoT security\n",
        "\n",
        "Mohammad Abdullah Tahir<br>\n",
        "Ornel Vojka<br>\n",
        "Yasser Kassab<br>"
      ]
    },
    {
      "cell_type": "markdown",
      "id": "299a4e54",
      "metadata": {
        "id": "299a4e54"
      },
      "source": [
        "This lab focuses on the implementation of security methods and algorithms for Internet of Things (IoT)."
      ]
    },
    {
      "cell_type": "code",
      "execution_count": 1,
      "id": "5926baef",
      "metadata": {
        "id": "5926baef"
      },
      "outputs": [],
      "source": [
        "import random\n",
        "import sys\n",
        "import datetime\n",
        "from random import randint\n",
        "import numpy\n",
        "import numpy\n",
        "import os"
      ]
    },
    {
      "cell_type": "markdown",
      "id": "9e7f1f77",
      "metadata": {
        "id": "9e7f1f77"
      },
      "source": [
        "## CONSTITUTION OF RANDOM GENERATORS"
      ]
    },
    {
      "cell_type": "markdown",
      "id": "892df9ec",
      "metadata": {
        "id": "892df9ec"
      },
      "source": [
        "### LINEAR CONGRUENTIAL GENERATORS"
      ]
    },
    {
      "cell_type": "markdown",
      "id": "0ba606cc",
      "metadata": {
        "id": "0ba606cc"
      },
      "source": [
        "We will employ the Linear Congruential Generator (LCG) algorithm, denoted as Xn+1 = (a * Xn + c) % m, to enhance encryption using one-time disposable masks. The specific values for 'a,' 'c,' and 'm' were selected based on common choices found in literature and online references."
      ]
    },
    {
      "cell_type": "code",
      "execution_count": 2,
      "id": "1b8c3e65",
      "metadata": {
        "colab": {
          "base_uri": "https://localhost:8080/"
        },
        "id": "1b8c3e65",
        "outputId": "d323c4d5-41fc-41c0-d93a-9c828e5d39c8"
      },
      "outputs": [
        {
          "output_type": "stream",
          "name": "stdout",
          "text": [
            "0010010100011110010111110\n"
          ]
        }
      ],
      "source": [
        "def lcg(x, a, c, m):\n",
        "    while True:\n",
        "        x = (a * x + c) % m\n",
        "        yield x\n",
        "\n",
        "def random_uniform_sample(n, interval, seed=0):\n",
        "    a, c, m = 1103515245, 12345, 2 ** 31\n",
        "    bsdrand = lcg(seed, a, c, m)\n",
        "    lower, upper = interval[0], interval[1]\n",
        "    return [(upper - lower) * (next(bsdrand) / (2 ** 31 - 1)) + lower for _ in range(n)]\n",
        "\n",
        "def disposable_mask_lcg(payload):\n",
        "    rus = random_uniform_sample(30, [0, 100])\n",
        "    n = random.randint(0, 29)\n",
        "    key1 = int(rus[n])  # Convert to integer\n",
        "    encrypted = int(payload, 2) ^ key1\n",
        "    return bin(encrypted)[2:].zfill(len(payload))\n",
        "\n",
        "result = disposable_mask_lcg(\"0010010100011110011111110\")\n",
        "print(result)"
      ]
    },
    {
      "cell_type": "markdown",
      "id": "938bb4f3",
      "metadata": {
        "id": "938bb4f3"
      },
      "source": [
        "### XORSHIFT"
      ]
    },
    {
      "cell_type": "markdown",
      "id": "4d66bd80",
      "metadata": {
        "id": "4d66bd80"
      },
      "source": [
        "Xorshift random number generators, often referred to as shift-register generators, are a particularly suitable choice for connected objects with limited computational resources. This is because they don't require complex calculations, making them an efficient option for resource-constrained devices."
      ]
    },
    {
      "cell_type": "code",
      "execution_count": 3,
      "id": "5e4c7c54",
      "metadata": {
        "id": "5e4c7c54"
      },
      "outputs": [],
      "source": [
        "def xor_shift():\n",
        "    X, Y, Z, W = 123456789, 362436069, 521288629, 88675123\n",
        "    t = (X ^ (X << 11))\n",
        "    X, Y, Z, W = Y, Z, W, t  # Include the 't' value in the unpacking\n",
        "    return W ^ (W >> 19) ^ (t ^ (t >> 8))"
      ]
    },
    {
      "cell_type": "markdown",
      "id": "cfba3a99",
      "metadata": {
        "id": "cfba3a99"
      },
      "source": [
        "### Linear-feedback shift register"
      ]
    },
    {
      "cell_type": "markdown",
      "id": "5b976151",
      "metadata": {
        "id": "5b976151"
      },
      "source": [
        "I have implemented Fibonacci Linear Feedback Shift Registers (LFSRs) in this code. LFSRs are shift registers in which the input bit is computed as a linear function of the previous state, and the Fibonacci LFSR is a specific type of LFSR."
      ]
    },
    {
      "cell_type": "code",
      "execution_count": 4,
      "id": "76ba0f66",
      "metadata": {
        "colab": {
          "base_uri": "https://localhost:8080/"
        },
        "id": "76ba0f66",
        "outputId": "148cd1bf-8756-4d37-be00-adbed04d5d5e"
      },
      "outputs": [
        {
          "output_type": "execute_result",
          "data": {
            "text/plain": [
              "[(62, 2032),\n",
              " (127, 4032),\n",
              " (252, 8096),\n",
              " (506, 16224),\n",
              " (1014, 32480),\n",
              " (2030, 64992),\n",
              " (4062, 130016),\n",
              " (8126, 260064),\n",
              " (16254, 520160),\n",
              " (32510, 1040352)]"
            ]
          },
          "metadata": {},
          "execution_count": 4
        }
      ],
      "source": [
        "def lfsr(seed, mask, period=10):\n",
        "    result = seed\n",
        "    nbits = mask.bit_length() - 1\n",
        "    sample = []\n",
        "\n",
        "    for _ in range(period):\n",
        "        result <<= 1\n",
        "        xor = result >> nbits\n",
        "        if xor:\n",
        "            result ^= mask\n",
        "        sample.append((xor, result))\n",
        "\n",
        "    return sample\n",
        "\n",
        "lfsr(1000, 32)"
      ]
    },
    {
      "cell_type": "markdown",
      "id": "048934b7",
      "metadata": {
        "id": "048934b7"
      },
      "source": [
        "### Mersenne Twister\n"
      ]
    },
    {
      "cell_type": "markdown",
      "id": "b370d378",
      "metadata": {
        "id": "b370d378"
      },
      "source": [
        "The Mersenne Twister PRNG (Pseudorandom Number Generator) was carefully designed to rectify the shortcomings often found in earlier PRNGs."
      ]
    },
    {
      "cell_type": "code",
      "execution_count": 17,
      "id": "870eb775",
      "metadata": {
        "colab": {
          "base_uri": "https://localhost:8080/"
        },
        "id": "870eb775",
        "outputId": "33879793-83e8-4248-e818-21f98569a04a"
      },
      "outputs": [
        {
          "output_type": "stream",
          "name": "stdout",
          "text": [
            "0.817330 0.517377 0.289666 0.618079 0.865585 0.501680 0.759883 0.984664 0.511649 0.478744 0.613782 0.627566 0.263673 0.140128 0.823456 0.730530 0.229505 0.579113 0.310494 0.142069 0.329454 0.869617 0.381442 0.878992 0.456209 0.435798 0.770097 0.617573 0.690495 0.839558 "
          ]
        }
      ],
      "source": [
        "import sys\n",
        "\n",
        "# Period parameters\n",
        "N = 624\n",
        "M = 397\n",
        "MATRIX_A = 0x9908b0df  # Constant vector a\n",
        "UPPER_MASK = 0x80000000  # Most significant w-r bits\n",
        "LOWER_MASK = 0x7fffffff  # Least significant r bits\n",
        "\n",
        "# Tempering parameters\n",
        "TEMPERING_MASK_B = 0x9d2c5680\n",
        "TEMPERING_MASK_C = 0xefc60000\n",
        "\n",
        "def TEMPERING_SHIFT_U(y):\n",
        "    return (y >> 11)\n",
        "\n",
        "def TEMPERING_SHIFT_S(y):\n",
        "    return (y << 7)\n",
        "\n",
        "def TEMPERING_SHIFT_T(y):\n",
        "    return (y << 15)\n",
        "\n",
        "def TEMPERING_SHIFT_L(y):\n",
        "    return (y >> 18)\n",
        "\n",
        "mt = []   # The array for the state vector\n",
        "mti = N + 1  # mti == N + 1 means mt[N] is not initialized\n",
        "\n",
        "# Initializing the array with a NONZERO seed\n",
        "def sgenrand(seed):\n",
        "    global mt, mti\n",
        "\n",
        "    mt = []\n",
        "\n",
        "    mt.append(seed & 0xffffffff)\n",
        "    for i in range(1, N + 1):\n",
        "        mt.append((69069 * mt[i - 1]) & 0xffffffff)\n",
        "\n",
        "    mti = i\n",
        "\n",
        "# End sgenrand\n",
        "\n",
        "def genrand(seed):\n",
        "    global mt, mti\n",
        "    mag01 = [0x0, MATRIX_A]  # mag01[x] = x * MATRIX_A for x=0,1\n",
        "    y = 0\n",
        "\n",
        "    if mti >= N:  # Generate N words at one time\n",
        "        if mti == N + 1:  # If sgenrand() has not been called, a default initial seed is used\n",
        "            sgenrand(seed)\n",
        "\n",
        "    for kk in range((N - M) + 1):\n",
        "        y = (mt[kk] & UPPER_MASK) | (mt[kk + 1] & LOWER_MASK)\n",
        "        mt[kk] = mt[kk + M] ^ (y >> 1) ^ mag01[y & 0x1]\n",
        "\n",
        "    for kk in range(kk, N):\n",
        "        y = (mt[kk] & UPPER_MASK) | (mt[kk + 1] & LOWER_MASK)\n",
        "        mt[kk] = mt[kk + (M - N)] ^ (y >> 1) ^ mag01[y & 0x1]\n",
        "\n",
        "    y = (mt[N - 1] & UPPER_MASK) | (mt[0] & LOWER_MASK)\n",
        "    mt[N - 1] = mt[M - 1] ^ (y >> 1) ^ mag01[y & 0x1]\n",
        "\n",
        "    mti = 0\n",
        "\n",
        "    y = mt[mti]\n",
        "    mti += 1\n",
        "    y ^= TEMPERING_SHIFT_U(y)\n",
        "    y ^= TEMPERING_SHIFT_S(y) & TEMPERING_MASK_B\n",
        "    y ^= TEMPERING_SHIFT_T(y) & TEMPERING_MASK_C\n",
        "    y ^= TEMPERING_SHIFT_L(y)\n",
        "    return float(y) / 0xffffffff  # Real numbers\n",
        "\n",
        "def mersenne_twister(n, seed=4357):\n",
        "    sgenrand(seed)  # Any nonzero integer can be used as a seed\n",
        "    for j in range(n):\n",
        "        sys.stdout.write('%5f ' % genrand(seed))\n",
        "        if (j % 8) == 7:\n",
        "            print\n",
        "\n",
        "mersenne_twister(30)"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": 12,
      "id": "7109020e",
      "metadata": {
        "colab": {
          "base_uri": "https://localhost:8080/"
        },
        "id": "7109020e",
        "outputId": "3df1c9d5-ef5c-4071-d54f-de57ce2a31a3"
      },
      "outputs": [
        {
          "output_type": "stream",
          "name": "stdout",
          "text": [
            "XOR Shift :\n",
            "Answer\n",
            " 987654211 987654211 987654211 987654211 987654211 987654211\n",
            "Execution Time\n",
            " 2.618 Mili seconds\n"
          ]
        }
      ],
      "source": [
        "start_time = datetime.datetime.now()\n",
        "\n",
        "W1 = xor_shift() # 252977563114\n",
        "W2 = xor_shift() # 646616338854\n",
        "W3 = xor_shift() # 476657867818\n",
        "W4 = xor_shift() # 252977563114\n",
        "W5 = xor_shift() # 646616338854\n",
        "W6 = xor_shift() # 476657867818\n",
        "\n",
        "\n",
        "print(\"XOR Shift :\")\n",
        "print(\"Answer\\n\",W1 , W2, W3, W4 , W5, W6)\n",
        "end_time = datetime.datetime.now()\n",
        "time_diff = (end_time - start_time)\n",
        "execution_time = time_diff.total_seconds() * 1000\n",
        "\n",
        "print(\"Execution Time\\n\",execution_time, \"Mili seconds\")"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": 18,
      "id": "cc8844d4",
      "metadata": {
        "colab": {
          "base_uri": "https://localhost:8080/"
        },
        "id": "cc8844d4",
        "outputId": "c6a699bf-4499-4530-8bea-995ca548a94e"
      },
      "outputs": [
        {
          "output_type": "stream",
          "name": "stdout",
          "text": [
            "lCG : answer and execution time [0.0005748588594490936, 65.51540487702722, 30.481432345919977, 67.49606340541321, 10.676848381141596, 51.65744472837888] \n",
            "\n",
            "1.615 Mili seconds\n"
          ]
        }
      ],
      "source": [
        "start_time = datetime.datetime.now()\n",
        "print(\"lCG : answer and execution time\", random_uniform_sample(6, [0, 100]), \"\\n\")\n",
        "end_time = datetime.datetime.now()\n",
        "time_diff = (end_time - start_time)\n",
        "execution_time = time_diff.total_seconds() * 1000\n",
        "print(execution_time, \"Mili seconds\")"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": 19,
      "id": "14cc65b0",
      "metadata": {
        "colab": {
          "base_uri": "https://localhost:8080/"
        },
        "id": "14cc65b0",
        "outputId": "38adf3e4-0443-44ca-a00f-0cb6d93f50bd"
      },
      "outputs": [
        {
          "output_type": "stream",
          "name": "stdout",
          "text": [
            "LFSR : answer and execution time [(62, 2032), (127, 4032), (252, 8096), (506, 16224), (1014, 32480), (2030, 64992), (4062, 130016), (8126, 260064), (16254, 520160), (32510, 1040352)] \n",
            "\n",
            "0.24899999999999997 Mili seconds\n"
          ]
        }
      ],
      "source": [
        "start_time = datetime.datetime.now()\n",
        "print(\"LFSR : answer and execution time\", lfsr(1000,32), \"\\n\")\n",
        "end_time = datetime.datetime.now()\n",
        "time_diff = (end_time - start_time)\n",
        "execution_time = time_diff.total_seconds() * 1000\n",
        "print(execution_time, \"Mili seconds\")"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": 20,
      "id": "2d6efdb7",
      "metadata": {
        "colab": {
          "base_uri": "https://localhost:8080/"
        },
        "id": "2d6efdb7",
        "outputId": "c982296d-9159-4e00-8d39-bb8005605ee1"
      },
      "outputs": [
        {
          "output_type": "stream",
          "name": "stdout",
          "text": [
            "0.817330 0.517377 0.289666 0.618079 0.865585 0.501680 0.759883 0.984664 0.511649 0.478744 0.613782 0.627566 0.263673 0.140128 0.823456 0.730530 0.229505 0.579113 0.310494 0.142069 0.329454 0.869617 0.381442 0.878992 0.456209 0.435798 0.770097 0.617573 0.690495 0.839558 Mersenne twister : answer None \n",
            "\n",
            "18.466 mili seconds\n"
          ]
        }
      ],
      "source": [
        "start_time = datetime.datetime.now()\n",
        "print(\"Mersenne twister : answer\", mersenne_twister(30), \"\\n\")\n",
        "end_time = datetime.datetime.now()\n",
        "time_diff = (end_time - start_time)\n",
        "execution_time = time_diff.total_seconds() * 1000\n",
        "print(execution_time, \"mili seconds\")"
      ]
    },
    {
      "cell_type": "markdown",
      "id": "7210ab19",
      "metadata": {
        "id": "7210ab19"
      },
      "source": [
        "**It's evident from the elapsed execution time that the Mersenne Twister method requires a longer duration to complete compared to the other methods.**"
      ]
    },
    {
      "cell_type": "markdown",
      "id": "66b776c6",
      "metadata": {
        "id": "66b776c6"
      },
      "source": [
        "# **Blum Blum Shub**\n",
        "The BBS (Blum-Blum-Shub) is a pseudorandom bit generator designed to produce random binary bits rather than integer values. The return value from the BBS algorithm represents the parity bit of the result obtained from the operation Xn+1 = (Xn^2) mod M. In this context, the parity bit is a bit that ensures the overall \"evenness\" or \"oddness\" of the result, and it serves as the generated random bit. The BBS algorithm is based on the mathematical properties of quadratic residues, making it a unique and robust method for generating pseudorandom binary sequences."
      ]
    },
    {
      "cell_type": "code",
      "execution_count": 21,
      "id": "0e73147c",
      "metadata": {
        "colab": {
          "base_uri": "https://localhost:8080/"
        },
        "id": "0e73147c",
        "outputId": "3fbaed7f-a728-40d7-9265-ce95248e9226"
      },
      "outputs": [
        {
          "output_type": "stream",
          "name": "stdout",
          "text": [
            "01101110010111100000000011111011\n"
          ]
        }
      ],
      "source": [
        "import random\n",
        "\n",
        "def is_prime(number):\n",
        "    if number <= 1:\n",
        "        return False\n",
        "    for i in range(2, int(number**0.5) + 1):\n",
        "        if number % i == 0:\n",
        "            return False\n",
        "    return True\n",
        "\n",
        "def generate_primes_list(limit):\n",
        "    primes = [num for num in range(2, limit) if is_prime(num)]\n",
        "    return primes\n",
        "\n",
        "def generate_two_primes(primes_list):\n",
        "    out_primes = []\n",
        "    while len(out_primes) < 2:\n",
        "        current_prime = primes_list[random.randrange(len(primes_list))]\n",
        "        if current_prime % 4 == 3:\n",
        "            out_primes.append(current_prime)\n",
        "    return out_primes\n",
        "\n",
        "def random_bit_generator(length, primes_list):\n",
        "    x = random.randrange(1000000)\n",
        "    while length:\n",
        "        x += 1\n",
        "        p, q = generate_two_primes(primes_list)\n",
        "        m = p * q\n",
        "        z = (x**2) % m\n",
        "        length -= 1\n",
        "        yield str(bin(z).count('1') % 2)\n",
        "\n",
        "def get_random_bits(length):\n",
        "    primes_list = generate_primes_list(1000)  # Adjust the limit as needed\n",
        "    return ''.join(random_bit_generator(length, primes_list))\n",
        "\n",
        "random_bits = get_random_bits(32)\n",
        "print(random_bits)"
      ]
    },
    {
      "cell_type": "markdown",
      "id": "8eaacc6f",
      "metadata": {
        "id": "8eaacc6f"
      },
      "source": [
        "# **RAPID EXPONENTIATION**\n"
      ]
    },
    {
      "cell_type": "markdown",
      "id": "8b3cd230",
      "metadata": {
        "id": "8b3cd230"
      },
      "source": [
        "The fastest method for exponentiation leverages binary representation by converting it into a sequence of \"S\" and \"X\" characters. This sequence is then utilized to perform the exponentiation calculations efficiently. By using a binary string to guide the process, we can optimize the exponentiation operation, making it faster and more straightforward. This technique simplifies the computation by taking advantage of the inherent binary structure of numbers, allowing for rapid exponentiation without the need for complex multiplications and divisions."
      ]
    },
    {
      "cell_type": "code",
      "execution_count": 22,
      "id": "cd165d4e",
      "metadata": {
        "colab": {
          "base_uri": "https://localhost:8080/"
        },
        "id": "cd165d4e",
        "outputId": "2f0eaf35-78f0-4b96-cb28-31cb0727f38c"
      },
      "outputs": [
        {
          "output_type": "stream",
          "name": "stdout",
          "text": [
            "1024\n"
          ]
        }
      ],
      "source": [
        "def fast_exponentiation(a, n):\n",
        "    # Convert n to binary\n",
        "    binary_n = \"{0:b}\".format(n)\n",
        "    binary_exp = binary_n[1:]\n",
        "\n",
        "    # Convert binary representation to an 'S' and 'SX' string\n",
        "    exp_str = \"\"\n",
        "    for bit in binary_exp:\n",
        "        if bit == '0':\n",
        "            exp_str += \"S\"\n",
        "        else:\n",
        "            exp_str += \"SX\"\n",
        "\n",
        "    result = a\n",
        "\n",
        "    # Perform exponentiation using the 'S' and 'SX' string\n",
        "    for operation in exp_str:\n",
        "        if operation == 'S':\n",
        "            result *= result\n",
        "        elif operation == 'X':\n",
        "            result *= a\n",
        "\n",
        "    return result\n",
        "\n",
        "# Example usage:\n",
        "base = 2\n",
        "exponent = 10\n",
        "result = fast_exponentiation(base, exponent)\n",
        "print(result)"
      ]
    },
    {
      "cell_type": "markdown",
      "id": "be4b0bf2",
      "metadata": {
        "id": "be4b0bf2"
      },
      "source": [
        "# **OBTAINING LARGE PRIME NUMBERS**\n"
      ]
    },
    {
      "cell_type": "markdown",
      "id": "7b36c1c5",
      "metadata": {
        "id": "7b36c1c5"
      },
      "source": [
        "## **ERATOSTHENES' SIEVE**\n"
      ]
    },
    {
      "cell_type": "markdown",
      "id": "febca41b",
      "metadata": {
        "id": "febca41b"
      },
      "source": [
        "This method is effective for checking the primality of relatively small numbers. It allows us to determine whether any natural number less than or equal to `N` is prime or composite. The reason this algorithm generates smaller primes than `N` is that it iterates through all numbers from 0 to `N`, stopping at `N/2` because we are checking for multiples or numbers like `p * p`. However, it's important to note that this method requires auxiliary space in the order of `O(n)`. As the number `n` grows, the allocated space also increases, which may not be suitable for resource-constrained IoT devices with limited resources.\n"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": 23,
      "id": "b3dcac25",
      "metadata": {
        "colab": {
          "base_uri": "https://localhost:8080/"
        },
        "id": "b3dcac25",
        "outputId": "ddb5708f-d150-4dc0-e46f-078b2a77fc2d"
      },
      "outputs": [
        {
          "output_type": "stream",
          "name": "stdout",
          "text": [
            "Prime numbers smaller than or equal to 50:\n",
            "[2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47]\n"
          ]
        }
      ],
      "source": [
        "def SieveOfEratosthenes(num):\n",
        "    # Create a boolean array to mark numbers as prime or not\n",
        "    prime = [True for i in range(num + 1)]\n",
        "\n",
        "    p = 2\n",
        "    while p * p <= num:\n",
        "        if prime[p]:\n",
        "            # If prime[p] is True, update multiples of p to False\n",
        "            for i in range(p * p, num + 1, p):\n",
        "                prime[i] = False\n",
        "        p += 1\n",
        "\n",
        "    # Collect the prime numbers\n",
        "    prime_numbers = []\n",
        "    for p in range(2, num + 1):\n",
        "        if prime[p]:\n",
        "            prime_numbers.append(p)\n",
        "\n",
        "    return prime_numbers\n",
        "\n",
        "# Driver code\n",
        "num = 50\n",
        "print(f\"Prime numbers smaller than or equal to {num}:\")\n",
        "print(SieveOfEratosthenes(num))"
      ]
    },
    {
      "cell_type": "markdown",
      "id": "5b45517c",
      "metadata": {
        "id": "5b45517c"
      },
      "source": [
        "# **A FERMAT THEOREM**\n"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": 24,
      "id": "79849539",
      "metadata": {
        "colab": {
          "base_uri": "https://localhost:8080/"
        },
        "id": "79849539",
        "outputId": "fed2203b-de97-4387-a91e-d02c7bbb53a8"
      },
      "outputs": [
        {
          "output_type": "stream",
          "name": "stdout",
          "text": [
            "Prime numbers up to 50 using Fermat Primality Test:\n",
            "[2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47]\n"
          ]
        }
      ],
      "source": [
        "import random\n",
        "\n",
        "def fermat_test(n, k):\n",
        "    \"\"\"\n",
        "    Performs the Fermat Primality Test to check if a number is prime or composite.\n",
        "\n",
        "    Args:\n",
        "        n (int): The number to be tested.\n",
        "        k (int): The number of test iterations.\n",
        "\n",
        "    Returns:\n",
        "        bool: True if the number is likely prime, False if it's composite.\n",
        "    \"\"\"\n",
        "    if n <= 1:\n",
        "        return False\n",
        "    if n == 2:\n",
        "        return True\n",
        "    if n % 2 == 0:\n",
        "        return False\n",
        "\n",
        "    for _ in range(k):\n",
        "        a = random.randint(1, n - 1)\n",
        "        if pow(a, n - 1, n) != 1:\n",
        "            return False\n",
        "\n",
        "    return True\n",
        "\n",
        "def fermat_primes_up_to(num):\n",
        "    \"\"\"\n",
        "    Finds prime numbers up to a given number using the Fermat Primality Test.\n",
        "\n",
        "    Args:\n",
        "        num (int): The maximum number to check for primality.\n",
        "\n",
        "    Returns:\n",
        "        list: A list of prime numbers found.\n",
        "    \"\"\"\n",
        "    prime_numbers = []\n",
        "    for i in range(2, num):\n",
        "        if fermat_test(i, num):\n",
        "            prime_numbers.append(i)\n",
        "    return prime_numbers\n",
        "\n",
        "# Example usage\n",
        "num = 50\n",
        "print(f\"Prime numbers up to {num} using Fermat Primality Test:\")\n",
        "print(fermat_primes_up_to(num))"
      ]
    },
    {
      "cell_type": "markdown",
      "id": "de79618a",
      "metadata": {
        "id": "de79618a"
      },
      "source": [
        "# **MILLER-RABIN**"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": 27,
      "id": "a3838987",
      "metadata": {
        "id": "a3838987"
      },
      "outputs": [],
      "source": [
        "import random\n",
        "\n",
        "def rabin_miller(num):\n",
        "    s = num - 1\n",
        "    t = 0\n",
        "\n",
        "    while s % 2 == 0:\n",
        "        s = s // 2\n",
        "        t += 1\n",
        "\n",
        "    for _ in range(5):\n",
        "        a = random.randrange(2, num - 1)\n",
        "        v = pow(a, s, num)\n",
        "        if v != 1:\n",
        "            i = 0\n",
        "            while v != (num - 1):\n",
        "                if i == t - 1:\n",
        "                    return False\n",
        "                else:\n",
        "                    i += 1\n",
        "                    v = (v ** 2) % num\n",
        "    return True\n",
        "\n",
        "def is_prime(num):\n",
        "    if num < 2:\n",
        "        return False\n",
        "\n",
        "    low_primes = [\n",
        "        2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71,\n",
        "        73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151,\n",
        "        157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 229, 233,\n",
        "        239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293, 307, 311, 313, 317,\n",
        "        331, 337, 347, 349, 353, 359, 367, 373, 379, 383, 389, 397, 401, 409, 419,\n",
        "        421, 431, 433, 439, 443, 449, 457, 461, 463, 467, 479, 487, 491, 499, 503,\n",
        "        509, 521, 523, 541, 547, 557, 563, 569, 571, 577, 587, 593, 599, 601, 607,\n",
        "        613, 617, 619, 631, 641, 643, 647, 653, 659, 661, 673, 677, 683, 691, 701,\n",
        "        709, 719, 727, 733, 739, 743, 751, 757, 761, 769, 773, 787, 797, 809, 811,\n",
        "        821, 823, 827, 829, 839, 853, 857, 859, 863, 877, 881, 883, 887, 907, 911,\n",
        "        919, 929, 937, 941, 947, 953, 967, 971, 977, 983, 991, 997\n",
        "    ]\n",
        "\n",
        "    if num in low_primes:\n",
        "        return True\n",
        "\n",
        "    for prime in low_primes:\n",
        "        if (num % prime == 0):\n",
        "            return False\n",
        "\n",
        "    return rabin_miller(num)\n",
        "\n",
        "def generate_large_prime(keysize=307):\n",
        "    while True:\n",
        "        num = random.randrange(2 ** (keysize - 1), 2 ** keysize)\n",
        "        if is_prime(num):\n",
        "            return num\n"
      ]
    },
    {
      "cell_type": "markdown",
      "id": "3cd1a0be",
      "metadata": {
        "id": "3cd1a0be"
      },
      "source": [
        "# **KEY EXCHANGE**"
      ]
    },
    {
      "cell_type": "markdown",
      "id": "02a6fcb4",
      "metadata": {
        "id": "02a6fcb4"
      },
      "source": [
        "## **Diffieâ€“Hellman**"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": 28,
      "id": "5ebc1c9e",
      "metadata": {
        "colab": {
          "base_uri": "https://localhost:8080/"
        },
        "id": "5ebc1c9e",
        "outputId": "08a53d70-9495-45ae-80a2-e2f94081f6d6"
      },
      "outputs": [
        {
          "output_type": "stream",
          "name": "stdout",
          "text": [
            "The Value of P is: 23\n",
            "The Value of G is: 9\n",
            "Eve's Private Key is: 7\n",
            "Mallory's Private Key is: 5\n",
            "Eve's Public Key (x) is: 4\n",
            "Mallory's Public Key (y) is: 8\n",
            "Shared Secret Key for Eve: 12\n",
            "Shared Secret Key for Mallory: 12\n",
            "Shared secret keys match. Secure communication is established.\n"
          ]
        }
      ],
      "source": [
        "def diffie_hellman():\n",
        "    # Both Eve and Mallory agree upon the\n",
        "    # public keys G and P\n",
        "    # A prime number P is chosen\n",
        "    P = 23\n",
        "    # A primitive root for P, G is chosen\n",
        "    G = 9\n",
        "    print('The Value of P is: %d' % P)\n",
        "    print('The Value of G is: %d' % G)\n",
        "\n",
        "    # Eve chooses her private key\n",
        "    eve_private_key = 7  # Eve's private key\n",
        "    print('Eve\\'s Private Key is: %d' % eve_private_key)\n",
        "\n",
        "    # Mallory chooses her private key\n",
        "    mallory_private_key = 5  # Mallory's private key\n",
        "    print('Mallory\\'s Private Key is: %d' % mallory_private_key)\n",
        "\n",
        "    # Calculate Eve's public key x and send it to Mallory\n",
        "    x = int(pow(G, eve_private_key, P))\n",
        "\n",
        "    # Calculate Mallory's public key y and send it to Eve\n",
        "    y = int(pow(G, mallory_private_key, P))\n",
        "\n",
        "    # Compute the shared secret key for Eve and Mallory\n",
        "    shared_secret_eve = int(pow(y, eve_private_key, P))\n",
        "    shared_secret_mallory = int(pow(x, mallory_private_key, P))\n",
        "\n",
        "    print('Eve\\'s Public Key (x) is: %d' % x)\n",
        "    print('Mallory\\'s Public Key (y) is: %d' % y)\n",
        "    print('Shared Secret Key for Eve: %d' % shared_secret_eve)\n",
        "    print('Shared Secret Key for Mallory: %d' % shared_secret_mallory)\n",
        "\n",
        "    if shared_secret_eve == shared_secret_mallory:\n",
        "        print('Shared secret keys match. Secure communication is established.')\n",
        "    else:\n",
        "        print('Shared secret keys do not match. Secure communication failed.')\n",
        "\n",
        "diffie_hellman()"
      ]
    },
    {
      "cell_type": "markdown",
      "id": "016cc6cb",
      "metadata": {
        "id": "016cc6cb"
      },
      "source": [
        "# **Asymmetric encryption algorithms:**\n"
      ]
    },
    {
      "cell_type": "markdown",
      "id": "aefdaa98",
      "metadata": {
        "id": "aefdaa98"
      },
      "source": [
        "### RSA"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": 30,
      "id": "70e0de50",
      "metadata": {
        "colab": {
          "base_uri": "https://localhost:8080/"
        },
        "id": "70e0de50",
        "outputId": "919a0dc0-3699-465d-f423-0e21781af3de"
      },
      "outputs": [
        {
          "output_type": "stream",
          "name": "stdout",
          "text": [
            "The encrypted data is 539\n",
            "The decrypted data is 122\n"
          ]
        }
      ],
      "source": [
        "import random\n",
        "\n",
        "def gcd(a, b):\n",
        "    # Calculate the greatest common divisor (GCD) of two numbers using Euclidean algorithm\n",
        "    while a != 0:\n",
        "        a, b = b % a, a\n",
        "    return b\n",
        "\n",
        "def findModInverse(a, m):\n",
        "    # Find the modular multiplicative inverse of 'a' modulo 'm'\n",
        "    if gcd(a, m) != 1:\n",
        "        return None\n",
        "    u1, u2, u3 = 1, 0, a\n",
        "    v1, v2, v3 = 0, 1, m\n",
        "\n",
        "    while v3 != 0:\n",
        "        q = u3 // v3\n",
        "        v1, v2, v3, u1, u2, u3 = (u1 - q * v1), (u2 - q * v2), (u3 - q * v3), v1, v2, v3\n",
        "    return u1 % m\n",
        "\n",
        "def generateKey(keySize):\n",
        "    # Generate RSA public and private keys\n",
        "    p1 = generate_large_prime(keySize)\n",
        "    p2 = generate_large_prime(keySize)\n",
        "    n = p1 * p2\n",
        "    while True:\n",
        "        c = random.randrange(2 ** (keySize - 1), 2 ** (keySize))\n",
        "        if gcd(c, (p1 - 1) * (p2 - 1)) == 1:\n",
        "            break\n",
        "    d = findModInverse(c, (p1 - 1) * (p2 - 1))\n",
        "    publicKey = (n, c)\n",
        "    privateKey = (n, d)\n",
        "    return (publicKey, privateKey)\n",
        "\n",
        "def encryption_rsa(plain_text, pub_key):\n",
        "    # Encrypt plaintext using RSA\n",
        "    tc = fast_exponentiation(plain_text, pub_key[1])\n",
        "    x = tc % pub_key[0]\n",
        "    return x\n",
        "\n",
        "def decryption_rsa(ciphertext, priv_key):\n",
        "    # Decrypt ciphertext using RSA\n",
        "    xd = fast_exponentiation(ciphertext, priv_key[1])\n",
        "    t = xd % priv_key[0]\n",
        "    return t\n",
        "\n",
        "# Generate RSA keys\n",
        "keys = generateKey(8)\n",
        "\n",
        "# Encrypt and decrypt a message\n",
        "plain_text = 122\n",
        "enc = encryption_rsa(plain_text, keys[0])\n",
        "dec = decryption_rsa(enc, keys[1])\n",
        "\n",
        "# Print the results\n",
        "print(\"The encrypted data is\", enc)\n",
        "print(\"The decrypted data is\", dec)"
      ]
    },
    {
      "cell_type": "markdown",
      "id": "d53dffa6",
      "metadata": {
        "id": "d53dffa6"
      },
      "source": [
        "### El Gamal"
      ]
    },
    {
      "cell_type": "markdown",
      "id": "5bdb735a",
      "metadata": {
        "id": "5bdb735a"
      },
      "source": [
        "On the field of integers modulo p"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": 31,
      "id": "dabbe125",
      "metadata": {
        "colab": {
          "base_uri": "https://localhost:8080/"
        },
        "id": "dabbe125",
        "outputId": "74ae39fd-b418-47d9-8e85-03ae45ea1400"
      },
      "outputs": [
        {
          "output_type": "stream",
          "name": "stdout",
          "text": [
            "Encrypted Message: 84531967795472688\n",
            "Decrypted Message: 122\n"
          ]
        }
      ],
      "source": [
        "import random\n",
        "\n",
        "def power(a, b, c):\n",
        "    # Compute (a^b) % c efficiently\n",
        "    x = 1\n",
        "    y = a\n",
        "\n",
        "    while b > 0:\n",
        "        if b % 2 != 0:\n",
        "            x = (x * y) % c\n",
        "        y = (y * y) % c\n",
        "        b = int(b / 2)\n",
        "\n",
        "    return x % c\n",
        "\n",
        "def generate_large_random_number(min_exponent, max_exponent):\n",
        "    # Generate a large random number in the specified range\n",
        "    return random.randint(2**min_exponent, 2**max_exponent)\n",
        "\n",
        "def generate_private_key(q):\n",
        "    # Generate a private key in the range (2, q)\n",
        "    key = random.randint(2, q)\n",
        "    while gcd(q, key) != 1:\n",
        "        key = random.randint(2, q)\n",
        "    return key\n",
        "\n",
        "def asymmetric_encrypt(msg, q, h, g):\n",
        "    # Encrypt a message using ElGamal encryption\n",
        "    k = generate_private_key(q)  # Private key for the sender\n",
        "    s = power(h, k, q)\n",
        "    p = power(g, k, q)\n",
        "    en_msg = s * msg\n",
        "    return en_msg, p\n",
        "\n",
        "def asymmetric_decrypt(en_msg, p, key, q):\n",
        "    # Decrypt an ElGamal-encrypted message\n",
        "    h = power(p, key, q)\n",
        "    dr_msg = en_msg // h\n",
        "    return dr_msg\n",
        "\n",
        "# Generate random values\n",
        "q = generate_large_random_number(10, 50)\n",
        "g = random.randint(2, q)\n",
        "msg = 122\n",
        "key = generate_private_key(q)  # Private key for the receiver\n",
        "h = power(g, key, q)\n",
        "\n",
        "# Encrypt and decrypt the message\n",
        "en_msg, p = asymmetric_encrypt(msg, q, h, g)\n",
        "print(\"Encrypted Message:\", en_msg)\n",
        "dmsg = int(asymmetric_decrypt(en_msg, p, key, q))\n",
        "print(\"Decrypted Message:\", dmsg)"
      ]
    },
    {
      "cell_type": "markdown",
      "id": "3336202d",
      "metadata": {
        "id": "3336202d"
      },
      "source": [
        "# ElGamal based Elliptic Curve Cryptography"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": 32,
      "id": "79a6ac74",
      "metadata": {
        "colab": {
          "base_uri": "https://localhost:8080/"
        },
        "id": "79a6ac74",
        "outputId": "1147995d-902e-46a4-8896-89a5d7b27a2b"
      },
      "outputs": [
        {
          "output_type": "stream",
          "name": "stdout",
          "text": [
            "Value of Cipher text 1 i.e. C1: ( 0 , 45 )\n",
            "\n",
            "Value of Cipher text 2 i.e. C2: ( 300 , 705 )\n",
            "\n",
            "The message received by receiver decrypted is: 300\n"
          ]
        }
      ],
      "source": [
        "import random\n",
        "\n",
        "def polynomial(LHS, RHS, n, a, b):\n",
        "    for i in range(n):\n",
        "        LHS[0].append(i)\n",
        "        RHS[0].append(i)\n",
        "        LHS[1].append((i * i * i + a * i + b) % n)\n",
        "        RHS[1].append((i * i) % n)\n",
        "\n",
        "def points_generate(LHS, RHS, arr_x, arr_y, n):\n",
        "    count = 0\n",
        "    for i in range(n):\n",
        "        for j in range(n):\n",
        "            if LHS[1][i] == RHS[1][j]:\n",
        "                count += 1\n",
        "                arr_x.append(LHS[0][i])\n",
        "                arr_y.append(RHS[0][j])\n",
        "    return count\n",
        "\n",
        "def elliptic_curve_elgamal(M):\n",
        "    n = 101  # Change to your desired field size\n",
        "    LHS = [[]]\n",
        "    RHS = [[]]\n",
        "    LHS.append([])\n",
        "    RHS.append([])\n",
        "    a = 2  # Adjust the curve parameters\n",
        "    b = 5\n",
        "    # Polynomial\n",
        "    polynomial(LHS, RHS, n, a, b)\n",
        "\n",
        "    arr_x = []\n",
        "    arr_y = []\n",
        "    # Generating base points\n",
        "    count = points_generate(LHS, RHS, arr_x, arr_y, n)\n",
        "\n",
        "    # Calculation of Base Point\n",
        "    bx = arr_x[0]\n",
        "    by = arr_y[0]\n",
        "\n",
        "    # Private key\n",
        "    d = random.randint(1, n - 1)\n",
        "\n",
        "    # Q i.e. sender's public key generation\n",
        "    Qx = d * bx\n",
        "    Qy = d * by\n",
        "\n",
        "    # Encryption\n",
        "    k = random.randint(1, n - 1)\n",
        "    # Plain text\n",
        "\n",
        "    # Cipher text 1 generation\n",
        "    C1x = k * bx\n",
        "    C1y = k * by\n",
        "    print(\"Value of Cipher text 1 i.e. C1: (\", C1x, \",\", C1y, \")\\n\")\n",
        "\n",
        "    # Cipher text 2 generation\n",
        "    C2x = k * Qx + M\n",
        "    C2y = k * Qy + M\n",
        "    print(\"Value of Cipher text 2 i.e. C2: (\", C2x, \",\", C2y, \")\\n\")\n",
        "\n",
        "    # Decryption\n",
        "    Mx = C2x - d * C1x\n",
        "    My = C2y - d * C1y\n",
        "    print(\"The message received by receiver decrypted is:\", Mx)\n",
        "\n",
        "elliptic_curve_elgamal(300)"
      ]
    },
    {
      "cell_type": "markdown",
      "id": "fd4d893e",
      "metadata": {
        "id": "fd4d893e"
      },
      "source": [
        "# **Blum-Goldwasser cryptosystem**\n"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": 33,
      "id": "b8d6bd63",
      "metadata": {
        "colab": {
          "base_uri": "https://localhost:8080/"
        },
        "id": "b8d6bd63",
        "outputId": "9d8beb93-79cb-473c-830e-b98b3b5ae357"
      },
      "outputs": [
        {
          "output_type": "stream",
          "name": "stdout",
          "text": [
            "N = 272953\n",
            "m = 10011100000100001100\n",
            "b = 00101100000010001011\n",
            "C = 10110000000110000111\n",
            "Plaintext  = 10011100000100001100\n",
            "Message m  = 10011100000100001100\n"
          ]
        }
      ],
      "source": [
        "# Function for XORing two strings\n",
        "def XOR(a, b):\n",
        "    a, b = str(a), str(b)\n",
        "    assert len(a) <= len(b)\n",
        "    result = \"\"\n",
        "    for i in range(len(a)):\n",
        "        result += str(int(a[i]) ^ int(b[i]))\n",
        "    return result\n",
        "\n",
        "# Function to check if a number is prime\n",
        "def is_prime_number(n):\n",
        "    if n <= 1:\n",
        "        return False\n",
        "    if n <= 3:\n",
        "        return True\n",
        "    if n % 2 == 0 or n % 3 == 0:\n",
        "        return False\n",
        "    i = 5\n",
        "    while i * i <= n:\n",
        "        if n % i == 0 or n % (i + 2) == 0:\n",
        "            return False\n",
        "        i += 6\n",
        "    return True\n",
        "\n",
        "def blum_goldwasser(m):\n",
        "    p = 499  # Prime number p\n",
        "    q = 547  # Prime number q\n",
        "    a = -57  # Adjusted parameter a\n",
        "    b = 52  # Adjusted parameter b\n",
        "    X0 = 159201  # Initial value\n",
        "\n",
        "    # Ensure p and q are prime and congruent to 3 (mod 4)\n",
        "    assert is_prime_number(p)\n",
        "    assert is_prime_number(q)\n",
        "    assert p % 4 == 3\n",
        "    assert q % 4 == 3\n",
        "\n",
        "    # Key Generation\n",
        "    N = p * q  # Compute N\n",
        "    print(\"N =\", N)\n",
        "\n",
        "    split_string_m = str(m)\n",
        "\n",
        "    # Encryption\n",
        "    X = [X0]\n",
        "    b = \"\"\n",
        "    L = len(split_string_m)\n",
        "    for i in range(L):\n",
        "        string_x = bin(X[-1])[2:]\n",
        "        size = len(string_x)\n",
        "        b_i = string_x[size - 1]\n",
        "        b = b_i + b\n",
        "        new_x = (X[i] ** 2) % N\n",
        "        X.append(new_x)\n",
        "    print(\"m =\", m)\n",
        "    print(\"b =\", b)\n",
        "    str_m = str(m)\n",
        "    ciphertext = XOR(str_m, b)\n",
        "    print(\"C =\", ciphertext)\n",
        "    XL = X[-1]\n",
        "    X0 = X[0]\n",
        "    XL_check = pow(X0, pow(2, L), N)\n",
        "    assert XL == XL_check\n",
        "\n",
        "    # This tuple represents what is being sent to Alice\n",
        "    sent_message = (ciphertext, XL)\n",
        "    y = sent_message[1]\n",
        "\n",
        "    # Decryption\n",
        "    firstExponent = (((p + 1) // 4) ** L) % (p - 1)\n",
        "    firstPhrase = \"({}^{}) mod {}\".format(y, firstExponent, p)\n",
        "    r_p = pow(y, firstExponent, p)\n",
        "\n",
        "    secondExponent = (((q + 1) // 4) ** L) % (q - 1)\n",
        "    secondPhrase = \"({}^{}) mod {}\".format(y, secondExponent, q)\n",
        "    r_q = pow(y, secondExponent, q)\n",
        "\n",
        "    NEWX0 = (q * pow(q, -1, p) * r_p + p * pow(p, -1, q) * r_q) % N\n",
        "    NEWX = [NEWX0]\n",
        "\n",
        "    b = \"\"\n",
        "    for i in range(L):\n",
        "        string_x = bin(NEWX[-1])[2:]\n",
        "        size = len(string_x)\n",
        "        b_i = string_x[size - 1]\n",
        "        b = b_i + b\n",
        "        new_x = (NEWX[i] ** 2) % N\n",
        "        NEWX.append(new_x)\n",
        "\n",
        "    plaintext = XOR(ciphertext, b)\n",
        "    print(\"Plaintext  =\", plaintext)\n",
        "    print(\"Message m  =\", m)\n",
        "\n",
        "    # Checking if decrypted ciphertext is the same as the original plaintext\n",
        "    assert str(m) == str(plaintext)\n",
        "\n",
        "# Usage\n",
        "message = 10011100000100001100\n",
        "blum_goldwasser(message)"
      ]
    },
    {
      "cell_type": "markdown",
      "id": "6a6a7590",
      "metadata": {
        "id": "6a6a7590"
      },
      "source": [
        "# **Conclusion**"
      ]
    },
    {
      "cell_type": "markdown",
      "id": "2d421098",
      "metadata": {
        "id": "2d421098"
      },
      "source": [
        "In the realm of connected objects and IoT devices, the choice of encryption methods is crucial, as it directly impacts the delicate balance between performance, resource efficiency, and robust security. While more complex encryption techniques like RSA offer high levels of security, they can be resource-intensive and less suitable for resource-constrained IoT devices.\n",
        "\n",
        "On the other hand, simpler methods such as the XOR shift algorithm are lightweight and ideal for IoT applications with limited resources. However, they tend to be less secure and easier to crack.\n",
        "\n",
        "The challenge in IoT lies in finding the right trade-off between performance and security. Achieving strong security in IoT systems is essential to build trust among users. The IoT world is constantly evolving to address these challenges and create a balance that ensures the safety of connected devices and the data they handle."
      ]
    },
    {
      "cell_type": "code",
      "source": [],
      "metadata": {
        "id": "Zj5kpFbImjNC"
      },
      "id": "Zj5kpFbImjNC",
      "execution_count": null,
      "outputs": []
    }
  ],
  "metadata": {
    "kernelspec": {
      "display_name": "Python 3 (ipykernel)",
      "language": "python",
      "name": "python3"
    },
    "language_info": {
      "codemirror_mode": {
        "name": "ipython",
        "version": 3
      },
      "file_extension": ".py",
      "mimetype": "text/x-python",
      "name": "python",
      "nbconvert_exporter": "python",
      "pygments_lexer": "ipython3",
      "version": "3.9.7"
    },
    "colab": {
      "provenance": [],
      "include_colab_link": true
    }
  },
  "nbformat": 4,
  "nbformat_minor": 5
}